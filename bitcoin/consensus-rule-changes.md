---
description: 컨센서스의 규칙이 바뀌면 Fork가 일어난다.
---

# Consensus Rule Changes

[https://developer.bitcoin.org/devguide/block\_chain.html](https://developer.bitcoin.org/devguide/block_chain.html) 를 참조하여 작성하였습니다.

## Consensus Rule Changes

컨센서스를 유지하기 위해서 모든 full node들은 같은 컨센서스 규칙에 의해 블록들을 검증한다. 그러나 보안 구멍을 보완하거나 혹은 새로운 기능을 추가하기 위해서 이 컨센서스의 규칙이 바껴야하는 경우가 있다. 컨센서스의 규칙이 새로 구현되면, 업그레이드가 안된 옛날 노드들은 예전 규칙을 따르고 업그레이드된 노드들은 새로운 규칙을 따르는 일이 발생한다. 그로 인해 아래와 같은 두가지의 컨센서스 깨짐\(consensus break\)이 일어난다.

* 새로운 컨센서스 규칙을 따르는 블록은 업그레이드된 노드에게는 승인되지만, 그렇지 않은 노드에서 거절된다. 예를 들어 새로운 기능이 추가된 블록에 대해서 업그레이드된 노드는 이를 이해하고 승인하지만, 업그레이드 되지 않은 노드들에서는 이 블록이 예전 규칙을 위반하는 것이기에 거절한다. 
* 새로운 컨센서스 규칙을 만족하지 않는 블록들이 업그레이드된 노드들에게서는 거절되지만 업그레이드되지 않은 노드에서는 승인된다. 예를 들어 보안상 문제가 있는 기능을 사용한 블록은 업그레이드된 노드들에게는 받아들여지지 않지만, 업그레이드 되지않은 블록에서는 승인된다.

위의 업그레이드 되지 않은 노드에서 거절이 일어나는 첫번째 경우, 업그레이드 되지 않은 노드들에서 데이터를 받아오는 mining software는 업그레이드된 노드들에게서 데이터를 받아오는 mining software와 같은 체인에 적지 않을 것이다. 그 결과 서로 다른 체인이 형성되는데 하나는 업그레이드된 노드들의 체인, 다른 하나는 업그레이드 되지 않은 노드들의 체인이다. 이렇게 절대로 합쳐질 수 없는 체인이 생성\(fork\)되는 것을 hard fork라고 한다.

![](../.gitbook/assets/image%20%28128%29.png)

업그레이드된 노드들에서 예전 블록을 거절하는 두번째 경우에, 업그레이드된 노드들이 전체 hash rate의 대다수를 차지 한다면\(**≒** 다수의 노드가 업그레이드된 노드\) 영구적으로 분화된\(diverging\) 하나의 체인을 가질 수 있다. 업그레이드 되지 않은 노드들이 업그레된 노드와 동일한 모든 블록을 유효한 것으로 받아드릴 것이기 때문에, 업그레이드된 노드가 더 강력한 체인을 구축하여 업그레이드 되지않은 노드들이 이를 best valid block chain으로 승인하게 한다. 이것이 soft fork라고 불린다.

![](../.gitbook/assets/image%20%28127%29.png)



## Detecting Fork

업그레이드 되지 않은 노드들은 두가지 타입의 포크 모두에서 잘못된 정보를 사용하고 배포함으로써 재정적 손실을 초래하는 여러 상황을 겪을 수 있다. 예를 들어, 업그레이드 되지 않은 노드가 업그레이드된 노드에서는 받아드려지지 않는 트랜잭션들\(절대 best block chain에 속할 수 없는 트랜잭션\)을 승인하고 또 다른 노드들에게 전달할 수 있다. 

비트코인 코어\(Bitcoin Core\)는 블록체인의 proof of work를 통해서 hard fork를 발견하는 코드를 포함한다. 만약 업그레이드 되지 않은 노드가 자신의 유효한 best chain보다 최소 6개의 작업증명이 더 많은 블록 헤더를 수신하는 경우에 그 노드는 "getnetworkinfo" RPC의 결과를 리포트한다. 이는 업그레이드 되지 않은 노드가 best block chain일 것 같은 block chain으로 분기할 수 없다는 경고이다.

Full node들은 블록과 트랜잭션의 버젼 넘버를 확인해서 이를 알 수 있다. 만약 블록이나 트랜잭션의 버젼 넘버가 노드가 사용하는 버젼 넘버보다 크다면, 노드는 최신의 컨센서스 규칙을 따르지 않는다는 것을 알게된다.

위 두가지 상황에서 모두, 명백히 현재의 컨센서스 규칙을 따르지 않는다고 판단된 노드에게서 오는 데이터들은 전달되지 않는다.

SPV 클라이언트도 역시 여러개의 full node에게 접속해서 이들의 block height를 비교하여 이를 알 수 있고, 버젼 넘버 또한 사용할 수 있다. 

